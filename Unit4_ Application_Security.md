# U4M1: Introduction
## 應用安全
1. 分為: 本地, 遠程
2. 由代碼, 輸入, 運行環境構成
3. 安全性包含: 保密性, 完整性, 可用性
4. 應用程序模型:
    1. 應用程序在環境之中
    2. 透過操作系統和其他物件交互
        1. 文件系統: 在操作系統內的數據
        2. 進程: 包含同系統下的其他應用程序
        3. 終端: 使用者
        4. 網路
5. 應用漏洞分析
    1. 在特定的操作環境中
    2. 包含: 
        1. 設計漏洞:
            1. 設計的邏輯缺陷
            2. 例如:身分驗證缺失, 錯誤的信任
            3. 難以自動識別, 需要有功能的了解
        2. 實現漏洞:
            1. 未預期的事件
            2. 例如: 意外輸入, 意外錯誤, 未預期事件順序
        3. 部屬漏洞:
            1.  錯誤的配置
            2. 例如: 弱密碼, 過多權限, 錯誤的系統
## 應用程序的生命週期
1. 使用高級語言編寫代碼
2. 編譯與解釋
    1. compiled編譯, 以C 語言在GNU/Linux 為例:
        1. pre-processing預處理: 使用cpp, 將代碼擴展使其包含額外信息
        2. compilation編譯: 使用gcc, 將預處理後的代碼轉換成彙編碼
        3. assembly彙編/組合: 使用as, 將彙編碼轉換成二進制機器碼, 生成目標文件
        4. linking連接: 使用ld, 將目標文件中的引用連接到正確的記憶體地址, 生成可執行文件
        5. CPU 可以直接處理ELF
    2. interpreted解釋/直譯:
        1. 多數語言會將代碼傳遞到編譯器翻譯成中間語言, 例如: Java bytecode
        - Java 的編譯和C 的編譯名同作用不同, Java 編譯只轉換成中間語言
        - 某些文章保這類型的編譯包含在解釋器中
        2. 解釋器逐行執行代碼
        - 某些文章把這步驟稱為是VM 處理
        - 某些解釋器會先將部分代碼編譯成機器語言, 直接交給CPU 處理以加快處理速度
3. 加載到內存
4. 執行
5. 終止

## 補充
c++ 編譯到鏈結
https://medium.com/@alastor0325/https-medium-com-alastor0325-compilation-to-linking-c07121e2803
Java是如何執行的
https://medium.com/@clu1022/java筆記-java是如何執行的-4238ac11c59d
編譯, 直譯, 即時編譯
https://blog.tarswork.com/post/interpretation-vs-compilation-and-aot-vs-jit/


# U4M2: executable format and assembly
## 可執行文件
1. ELF 可執行與可連接格式
    1. 分為四種類型
        1. 重定位文件: 還要經過linking 才能執行
        2. 可執行文件: 可以直接執行
        3. 共享庫: 具有連接訊息, 可以連接到其他可執行文件
        4. 核心: 發生故障時的進程內存快照
    2. 工具
        1. readelf
        2. file
    3. 格式
        1. 頭:
            1. magic number: 標記這是一個ELF文件
            2. 循址訊息
            3. 文件類型
            4. 類型
            5. 入口地址
            6. 程序頭地址
            7. 節頭地址
            8. 大小數量等訊息
        2. 程序頭表: 定義段結構
        3. segment段: 
        4. 多個section節:
            1. 每個節都有頭, 頭有類型和標誌
            2. 節頭類型
                1. PROGBITS: 程序的代碼或數據
                2. NOBITS: 不需要占用文件空間的程序部分, 加載時才會占用內存
                3. SYMTAB 和DYNSYM: 靜態和動態連接的符號表
                4. STRTAB: 標示符號和符號字串表
                5. REL 和REAL: 重定位信息
            3. 節頭標誌
                1. ALLOC: 需要分配內存的
                2. WRITE: 可寫的
                3. EXECINSTR: 可執行的
            4. 實例:
                1. .text: 是PROGBITS, ALLOC, EXECINSTR: 程序代碼
                2. .data: 是PROGBITS, ALLOC, WRITE: 初始化數據
                3. .rodata: 是PROGBITS, ALLOC: 只讀數據
                4. .bss: 是NOBITS, ALLOC, WRITE: 未初始化數據
                5. .init 和.fini: 是PROGBITS, ALLOC, EXECINSTR: 預執行和結束前代碼
        5. 節頭表: 定義節結構
2. PE 文件格式
    1. 也稱為EXE格式
    2. 只在Windows系統使用
## x86-64 CPU 和彙編基礎
1. x86 cpu: 初始為16bits, 後發展為32bits(4bytes), 64bits(8bytes), 指的是記憶體位置長度
2. x86-64:
    1. 雖稱為64, 但目前只使用48位
    2. 有16個64位通用寄存器
    3. 另有專用寄存器
        1. rflags: 程序和狀態控制, 32bits也稱為eflags
            2. eflags 幾個重要的位: SF符號標誌, ZF零標誌, CF進位標誌
        2. rip: 指令指針, 指向下一個執行指令位置
3. 數據大小
    1. byte字節
    2. word字
    3. doubleword雙字
    4. quadword四字
4. 字節序
    1. intel 小端序: 儲存0x03020100 到地址00F97B40h
        1. 00F97B40h: 00
        2. 00F97B41h: 01
        3. 00F97B42h: 02
        4. 00F97B43h: 03
    2. 大端序相反
5. 符號整數
    1. 泛指負數
    2. 例如: -2是0xFFFFFFFE, 轉換為十進位
        1. 1111111111111110, 翻轉
        2. 0000000000000001, 加一
        3. 0000000000000010, 轉十進位並加符號
        4. -2
    3. MIN_INT為-2147483648是0x80000000
    4. abs無法計算MIN_INT, 會直接返回MIN_INT


# U4M3: attack Unix
## Unix進程
## 攻擊Unix進程 路徑攻擊
1. 分類
    1. 文件訪問攻擊
        1. 路徑攻擊
        2. TOCTTOU檢查時間至使用時間
        3. 文件句柄重用
    2. 命令注入
    3. 內存破壞
        1. 棧破壞
        2. 堆破壞
2. 路徑攻擊
    1. 文件是通過路徑字符串來確定
    2. Dot-Dot 攻擊:
        1. 應用程式會使用用戶提供的路徑
        2. 攻擊者利用".."來訪問上級目錄, 以訪問其他文件
        3. 也稱為目錄遍歷攻擊
        4. 防範:
            1. 過濾用戶提供的路徑
            2. 使用chroot() 限制應用程式訪問
    3. PATH HOME 攻擊:
        1. PATH 環境變數提供路徑列表讓shell 搜索命令
        2. HOME 環境變量讓shell 可以擴展主目錄路徑, 例如"~/myfile.txt"會訪問主目錄下檔案
        3. 攻擊者藉由更改環境變量讓應用程式訪問到不正確的文件
        4. 防範: 使用絕對路徑
    4. 鏈結攻擊
        1. "ln -s " 與文件建立符號鏈接/軟鏈接
        2. "/etc/passwd"儲存登入訊息, 所有用戶可讀
        3. "/etc/shadow"儲存密碼哈希值, 僅root 可讀
        4. dtappgather攻擊
            1. 此應用程式會在創建一個0555權限的資料夾和臨時文件
            2. 把"/etc/shadow"和資料夾做軟連結
            3. 對資料夾的操作做會轉移到"/etc/shadow"
            4. "/etc/shadow"的權限被修改
        5. 防範:
            1. 應檢查路徑的屬性, 屬性不正確可能發生意外
            2. 臨時文件路徑盡可能不被預測
## TOCTTOU 攻擊和文件句柄重用
1. Time-of-check to time-of-use, 檢查到使用之間的時間差攻擊
    1. 利用檢查文件屬性和訪問文件之間的時間差和應用程式race競爭
    2. 部分應用程式會使用setuid-root 讓程式使用root 權限運行, 應用程式會檢查使用者有沒有對應權限
    3. 過程:
        1. 應用程式常用"access()"調用實際UID檢查權限, 也就是開啟程式使用者的UID
        2. 再用"open()"調用有效權限運行
        3. 此攻擊利用"access()"調用權限之後, 判斷權限正確後, 在"open()"之前, 把檔案建立符號鏈結
        4. 符號連結使得程式以"open()"去開啟不正確的檔案, 例如"/etc/shadow"
    4. 實踐上很困難, 尤其不知道程式執行的時間軸
    5. 防範:
        1. 調用文件不使用路徑, 而是使用file descriptor文件描述符
        2. 若是臨時文件可以使用"mkstemp()"創建並打開文件
2. 文件句柄重用
    1. 部分SUID應用程式會fork 外部進程
    2. 如果未設置close-on-exec 標誌, fork出的進程會繼承父進程已打開的文件描述符
    3. chpass攻擊
        1. OpenBSD 上用來編輯帳戶關聯數據庫訊息
        2. chpass會創建一個密碼數據庫副本, 並啟動編輯器讓用戶修改
        3. 使用vi可以跳出到shell, 而且shell指向密碼數據庫副本的文件描述符, 攻擊密碼數據庫副本
        4. 副本之後會合併到正本中
    5. 防範: 確保fork的進程沒有繼承文件描述符
## 命令注入攻擊
1. 應用程式常會調用外部命令, 例如"system()"或是popen()都是調用"/bin/sh"
2. 如果攻擊者可以控制傳遞給函數的字串, 便可以任意使用外部命令
3. 實例: Shellshock

