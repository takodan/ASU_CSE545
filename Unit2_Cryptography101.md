# U2M1: Cryptography 101
## 密碼學
1. 通信安全包含:
    1. 保密性: 不被他人知道. A傳給B, C不能讀到傳給B的消息
    2. 真實性: 送出和收取對象是正確的, 對象不是偽裝的. C不能偽裝成A發訊息給B
    3. 完整性: 沒有被修改. A傳給B, C不能竄改傳給B的消息
    4. 不可否認性: 對象確實有做出送出和收取的行為. A傳給B, A必定有傳出這個消息
    5. 如果違反, 但是不被破譯也能算是安全的
2. 加密流程:明文->加密(密鑰)->密文->解密(密鑰)->明文
3. 加密的重點
    1. 加密算法的理論強度
    2. 加密的實現有無漏洞
    3. 客戶端是否能實現加密強度
    4. 攻擊重點在於解密和密鑰
4. 密碼分析
    1. C密文, E算法, K密鑰, P明文 C=E_K(P)
    2. Ciphertext-Only Analysis密文攻擊: 只得到C, 嘗試得到P, 或是E或K
    3. Known-Plaintext Analysis已知明文攻擊: 有對應的CP, 嘗試得到E或K
    4. Chosen-Plaintext Analysis選擇明文攻擊: 沒有對應的CP, 但是可以給出自定的P得到C, 嘗試得到E或K
5. One-Time pad, OPT一次性密碼
    1. 已證明在理論上是安全的
    2. 以隨機的密鑰加密明文, 此密鑰只使用在此明文, 因此沒有密鑰就無法解密
    3. 理論上是安全的但是實現上有些問題
        1. 密鑰要夠隨機沒有規律, 實際上電腦難以達到
        2. 密鑰要夠長, 資料多大密鑰就會有多大
        3. 密鑰只能夠使用一次
    4. 許多加密原理都是基於OTP
6. 加密的安全性
    1. 破解成本或時間超過密文的價值或時效, 就可以被認為是安全的
    2. 現實上客戶多會是最薄弱的環節, 例如使用詞彙當作密碼就容易被字典攻擊破解

## 加密算法
1. 分類:
    1. 對成加密: 加密和解密使用同密鑰, 只有一個密鑰
    2. 非對稱加密: 使用兩個密鑰, 多分為公鑰私鑰, 一個只用來加密另一個解密, 知道一個不能被推算出另一個
    3. 隨機樹生成: 用在多種加密方法上, 電腦其實只能做到偽隨機, 實際上是用算法生成
2. one-way hash function單向散列/雜湊函數
    1. 不論輸入會產生固定長度輸出
    2. 轉換是單向的
    3. 轉換結果接近隨機函數的結果
    4. 實際是有固定密鑰進行制定
    5. 改變輸入一定會感變輸出(哈希值)
    6. 三抗性
        1. 原像抗性: 無法在有限時間從輸出計算出輸入, 也意味著輸出不能太短, 否則會被計算出所有輸入出對
        2. 次原像抗性: 無法找到另一個輸入和已知輸入產生同一個輸出
        3. 碰撞抗性: 無法找到兩個不同的輸入可以生成同一個輸出
    7. 能滿足三種抗性可以被認為是安全的單向散列函數
    8. 常見輸出會是16進位, 兩個字符代表一個字節
3. 常見算法:
    1. 對稱算法:
        1. RC4(不再安全)
        2. DES(不再安全)
        3. AES
    2. 非對稱算法:
        1. Diffie-Hellman
        2. RSA
        3. 橢圓曲線加密
    3. 單向散列/雜湊函數:
        1. MD4(不再安全)
        2. MD5(不再安全)
        3. SHA1
        4. SHA-256

## 對稱加密和非對稱加密算法
1. 模型: Alice和Bob是使用者, Eve是攻擊者
2. 對稱加密:
    1. A和B要採取同種密碼系統加密E
    2. A和B要採取同個密鑰K
    3. A加密消息M, 密文C = E_K(M)
    4. B用K解密, M = E_K(C)
3. 對稱加密優缺點:
    1. 優點:
        1. 保密: 知道K才能解密C得到M
        2. 真實: 知道K才能通信
        3. 完整: C被修改會出現錯誤的M
    2. 缺點:
        1. AB需要先傳送K才能進行加密傳送, K不會被加密
        2. 有K都會被認作A或B:
            1. A或B可以被冒充
            2. 可能會需要更多密鑰
            3. 沒辦法證明訊息就是A傳送的
4. KDC密鑰分發中心:
    1. 為解決對稱加密缺點, 增加一個中間人負責管理和分發密鑰
    2. A把密鑰Ka交給KDC, B把密鑰Kb交給KDC
    3. A想要傳送訊息, 告知KDC
    4. KDC把生成臨時密鑰Kt以Ka加密傳給A, 也把密鑰Kt以Kb加密傳給B
    5. 此密鑰Kt就會是被加密再傳送
5. KDC優缺點:
    1. 優點:
        1. 減少需要的密鑰數量, 方便維護
        2. Kt有加密, 且有時效性
    2. 缺點:
        1. 單點故障:
            1. 如果KDC被攻擊成功, 所有密鑰都會洩露
            2. KDC需要高可用性, KDC失效所有通訊都會停用
6. 非對稱加密:
    1. A和B要採取同種密碼系統E
    2. B傳送公鑰PKb給A
    3. A用PKb加密消息M, 密文C = E_PKb(M)
    4. B用私鑰SKb解密, M = E_SKb(C)
7. 非對稱加密優缺點:
    1. 優點:
        1. 保密: 公鑰被攔截也不能直接解密密文, 私鑰只保留在B
        2. 完整: C被修改仍然會出現錯誤的M
    2. 缺點:
        1. 只要有公鑰PKb就可以假冒A, 也就無法證明訊息是A發送的
8. 進階對稱加密:
    1. 有兩組公鑰私鑰, 但加密是可逆的
    2. A用密鑰SKa和密鑰PKb加密, B則用密鑰PKa和密鑰SKb解密
    3. 進階優點:
        1. 真實性: 只有A可以以SKa加密
        2. 不可否認性: 用PKa解密的訊息只有SKa可以加密, 只有A有SKa
    4. 但仍會受到中間人攻擊

## 攻擊非對稱加密
1. 中間人攻擊:
    1. Eve截獲了A和B發送的公鑰PKa和P公鑰Kb, 並傳送一個新的公鑰PKe給A和B
    2. 這樣A和B發送的訊息就會是用PKe加密, Eve就可以用私鑰SKe解密 
    3. Eve也可以利用原本的公鑰偽裝成A或B發送訊息
2. 公鑰證書:
    1. 為抵禦中間人攻擊, 簡單理解就是找可信的第三方做身分認證
    2. 由Certificate Authority認證機構發放證書作
    3. 流程:
        1. A和B把自己的公鑰PKa和PKb發給CA進行認證, CA會保留此公鑰並回傳CA公鑰PKca給A和B
        2. A要發送訊息給B, 會要和CA請求才能取得PKb, 把訊息用PKa和PKb加密
        3. B受到訊息, 要和CA請求才能取得PKa才能解密
    4. 和一般非對稱加密差異在於會需要另外和可信且受監督的機構驗證公鑰

# U2M2: unsafe encryption
## 糟糕的加密
1. 加密的重點複習
    1. 加密算法的理論強度
    2. 加密的實現有無漏洞
    3. 客戶端是否能實現加密強度
    4. 攻擊重點在於解密密文和取得密鑰
2. 弱加密
    1. 單向散列函數缺少對某種攻擊的抗性
        1. MD4, MD5, SHA1均被發現可以有效的碰撞攻擊, SHA256目前尚屬於安全
        2. 可以被碰撞攻擊表示兩個不同的密文會產出相同的哈希值, 便可以此偽裝密文
    2. 隨機數生成器使用容易被預測的種子
        1. 例如: 使用時間做為種子就可能被預測, 攻擊者以此推算出隨機數
        2. 在Linux 可以使用`/dev/radom`或`/dev/urandom`,Windows 可以使用`CryptGenRandom()`
        3. 測試隨機性的方式:
            1. 卡方測試
            2. Dierhard測試集
3. 糟糕加密的跡象
    1. 許多似是而非或是全新的數學概念
    2. 未經過證明的理論
    3. 極長的密鑰

## 實例: 安全的加密算法, 不安全的實現
1. 2008 Debian 的OpenSSL
    1. debug 時刪除了一段代碼, 使得隨機數產生的來源被簡化成進程ID
2. 2014 OpenSSL 的Heartbleed 漏洞
    1. TLS的心跳擴展是用來互傳封包已確定主機都在線上
    2. 但缺乏緩衝區邊界檢查, 使得攻擊者要求回傳超出範圍的傳封, 藉此取得其他內存數據
    3. 此漏洞攻擊發生在建立TLS連線之前, 多數防火前無法發現
3. 2017 X. 509證書驗證錯誤
    1. X. 509是用來進行使用者驗證的公鑰
    2. 被發現部分SSL庫不能正確的驗證X. 509
4. 2019 SSD硬體加密問題
    1. 有些硬體加密是使用固定密鑰而不是用戶指定
    2. 有些硬體加密密鑰是明文存在硬碟上的
5. RSA side-channel attack側信道攻擊
    1. 除了數位的正常的輸入輸出, 電腦運作還會有其他訊號可以被監測, 例如: 錯誤輸出, 運算時間 功耗等等
    2. 攻擊者可以藉此推算密鑰

## 實例:安全的算法和實現, 不安全的使用方法
1. 2010 How I met your girlfriend
    1. PHP會話cookies: 伺服器會生成一個cookies給使用者, 以方便確認使用者身分
    2. 此訊息的熵包含: IP, 時間到微秒, 隨機值和上線時間, 足夠的熵很難計算所有可能
    3. 攻擊者先取得目標IP(誘騙目標連接到攻擊者的網站)
    4. PHP的隨機種子是用時間和進程ID生成, 比較容易被取的
    5. 剩下無法取得的部分就會小到可以暴力破解
2. 2012 CRIME基於壓縮比的訊息更容易洩漏
    1. 如果要傳輸訊息, 壓縮必須先於加密
    2. 簡單的壓縮概念就是把重複的部分替換成比較短的字串
    3. 攻擊者針對HTTPS密文攻擊
    4. 攻擊者在HTTPS訊息開頭斷嘗試添加不同字符, 如果添加後的訊息較短, 代表此訊息有再進行壓縮
    4. 有壓縮也代表攻擊者添加的字符和目標原本的字符重複, 藉此推算HTTPS開頭的cookies
3. 2013 BREACH透過超文本自適應壓縮進行瀏覽器攻擊
    1. 為了避免CRIME, HTTPS規範開頭cookies不進行壓縮
    2. 但是內文還是會壓縮, 而且有些套件會把cookies保存在內文
    3. 最終解決方式:
        1. 完全不進行壓縮
        2. 用新的壓縮方式

## GPG加密
1. Pretty Good Privacy(PGP)加密軟體延伸開發了OpenPGP(RFC2440)標準
2. GnuPG是實現OpenPGP(RFC2440)標準的加密軟體, 提供訊息的加密和完整性驗證
3. 用戶可以生成多個公私鑰對
4. 可以生成ASCII 版本公鑰進行傳遞
5. 加密訊息方式:
    1. A生成一個隨機數對話密鑰CK
    2. 用B的公鑰PKb加密CK, 用CK加密訊息
    3. 打包成一個封包發送
    4. B用私鑰Skb解密CK, 再用CK解密訊息
6. 簽名訊息方式:
    1. A生成訊息m的哈希值h1
    2. A用私鑰SKa加密h, 附加在訊息m上發送
    3. B用PKa解密, 比對收到訊息的哈希值h2和副在訊息上的哈席值h
